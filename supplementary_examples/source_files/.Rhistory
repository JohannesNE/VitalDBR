install.packages(mgcv,gratia,dplyr,ggplot2,patchwork)
install.packages(mgcv)
install.packages("mgcv")
mgcv
install.packages("mgcv")
install.packages("mgcv")
mgcv
mgcv
library("mgcv")
mgcv
library("mgcv")
help("mgcv-package")
install.packages(gratia)
install.packages("gratia")
#install.packages("gratia")
library("gratia")
#install.packages("gratia")
library("gratia")
help("gratia")
#install.packages("gratia")
library("gratia")
??gratia
library(dplyr)
library("dplyr")
library("ggplot2")
install.packages("patchwork")
install.packages("patchwork")
install.packages("accelerometry")
#install.packages("patchwork")
library(patchwork)
??patchwork
#install.packages("accelerometry")
library(accelerometry)
knitr::opts_chunk$set(echo = TRUE,
message = FALSE,
#dpi = 150,
fig.width = 7,
fig.height = 5,
fig.retina = 2,
out.width = "70%",
fig.align = "center"
)
knitr::opts_template$set(wide = list(
fig.height=2, fig.width=10, out.width = "100%"
),
nooutput = list(fig.height=1, fig.width=1, out.width = "100%") # keep cache with default opt change
)
library(mgcv) # fitting GAMs
library(gratia) # visualising and working with GAMs
library(dplyr) # working with data-frames
library(ggplot2) # plotting
library(patchwork) # combining plots
# only used for heart beat detection (dependencies of `find_abp_beats()`)
# install.packages("accelerometry")
# install.packages("purrr")
theme_set(theme_minimal()) # Change the default plotting theme
sample_pp <- readRDS("sample_PP.RDS")
head(sample_pp$abp)
head(sample_pp$insp_start)
#| fig.cap = "Arterial blood pressure (ABP). Red lines indicate inspiration start."
abp_plot <- ggplot(sample_pp$abp, aes(time, ABP)) +
geom_line() +
geom_vline(aes(xintercept = time), color = "red",
data = sample_pp$insp_start)
abp_plot
source("functions.R")
beats <- find_abp_beats(sample_pp$abp)
head(beats)
#| fig.cap = "Beats are detected using `find_abp_beats()`."
abp_plot +
geom_point(aes(x = time,
y = dia,
colour = "diastole"),
data = beats) +
geom_point(aes(x = time_systole,
y = sys,
colour = "systole"),
data = beats)
#| fig.cap = "Pulse pressure (PP) of each heart beat."
pp_plot <- ggplot(beats, aes(time, PP)) +
geom_line() +
geom_point() +
geom_vline(aes(xintercept = time), color = "red",
data = sample_pp$insp_start)
pp_plot
beats_indexed <- add_time_since_event(beats,
time_events = sample_pp$insp_start$time,
prefix = "insp") %>%
# the first beats are earlier than the first inspiration and
# therefore have `insp_rel_index = NA`. We remove these.
na.omit()
# Show only time and the four newly added columns. The other columns from `beats`
# are also in `beats_indexed`.
head(beats_indexed %>% select(-(dia:.noise_pos_after_sys)))
#| fig.cap = "Pulse pressure indexed to the respiratory cycle."
pp_plot_color <- ggplot(beats_indexed, aes(time, PP)) +
geom_line() +
# insp_n is a unique (consecutive) number for each respiratory cycle
geom_point(aes(color = as.factor(insp_n)), show.legend = FALSE) +
geom_vline(aes(xintercept = time), color = "red",
data = sample_pp$insp_start) +
labs(title = "Pulse pressure",
subtitle = "by time. Color indicate respiratory cycle")
pp_insp_plot <- ggplot(beats_indexed,
aes(
insp_rel_index,
PP,
group = as.factor(insp_n),
color = as.factor(insp_n)
)
) +
geom_line(alpha = 0.3, show.legend = FALSE) +
# insp_n is a unique (consecutive) number for each respiratory cycle
geom_point(aes(color = as.factor(insp_n)), show.legend = FALSE) +
labs(subtitle = "by position in the respiratory cycle")
pp_plot_color + pp_insp_plot + plot_layout(widths = c(2,1))
PP_data <- select(beats_indexed, PP, time, insp_rel_index)
head(PP_data)
PP_gam <- gam(
# The first parameter to the gam() function is the model specification,
# supplied using formula notation:
PP ~ # Left of the tilde (~) is our dependent variable PP
# Right of the tilde is our independent variables.
# Define a smooth function of insp_rel_index.
s(insp_rel_index,
k = 15, # 15 knots.
bs = "cc" # The basis is a cyclic cubic spline
) +
# Define a smooth function of time
s(time,
bs = "cr" # The basis is a natural cubic spline.
# default k is 10. This will be fine here.
),
# We can specify the positions of the knots for each smooth.
# If only two knots are specified for a cyclic spline, these will
# set the positions of the limiting knot(s). The remaining knots will
# be positioned automatically (at quantiles).
knots = list(insp_rel_index = c(0,1)),
# We use restricted maximum likelihood (REML) to fit the optimal smoothing parameter.
# This is often the best choice, but not the default.
method = "REML",
data = PP_data
)
#| fig.cap = "Smooth effects of the pulse pressure GAM."
draw(PP_gam,
residuals = TRUE)
coef(PP_gam)[1]
#| fig.cap = "Observed and predicted pulse pressure."
PP_pred <- mutate(PP_data, pred = predict(PP_gam))
ggplot(PP_pred, aes(x=time)) +
geom_line(aes(y=PP, color = "Observed")) +
geom_point(aes(y=PP, color = "Observed")) +
geom_point(aes(y=pred, color = "Predicted"))
#| fig.cap = "Observed and predicted pulse pressure, including predictions between observations."
PP_newdata <- tibble(
# create 200 points from 0 to 30 to get a smooth line
time = seq(0, 30, length.out = 200)) %>%
# index each new time to our existing vector of inspiration times
add_time_since_event(sample_pp$insp_start$time, prefix = "insp") %>%
na.omit()
PP_interpolate <- bind_cols(
PP_newdata,
predict(PP_gam,
newdata = PP_newdata,
# in addition to the predictions (fit) also return the standard error
# (se.fit) for each prediction. This makes predict return a named list,
# that we can simply bind to our data frame.
se.fit = TRUE)
)
ggplot(PP_interpolate, aes(x=time)) +
geom_ribbon(aes(ymin = fit - 1.96*se.fit,
ymax = fit + 1.96*se.fit,
fill = "Predicted (95% CI)")) +
geom_line(aes(y = fit)) +
geom_point(aes(y=PP, color = "Observed"), data = PP_data) +
scale_fill_manual(values = "skyblue")
insp_rel_index_smooth <- smooth_estimates(PP_gam,
smooth = "s(insp_rel_index)",
n=100)
min_PP <- min(insp_rel_index_smooth$est)
max_PP <- max(insp_rel_index_smooth$est)
intercept_PP <- coef(PP_gam)[1]
PPV_est <- (max_PP - min_PP) / intercept_PP
sprintf("PPV is %.1f%%", PPV_est*100)
#| fig.cap = "Plot of 50 of the 5000 sampled smooths from the posterior distribution of the respiratory cycle smooth `s(insp_rel_inded)`."
set.seed(1)
insp_smooth_samples <- smooth_samples(PP_gam, term = "s(insp_rel_index)", n = 5000)
ggplot(insp_smooth_samples %>% filter(draw <= 50), aes(.x1, value, group = draw)) +
geom_line(alpha = 0.1) +
labs(x="insp_rel_index")
#| fig.cap = "Histogram of PPVs calculated from each of the 5000 sampled smooths from the posterior distribution of the respiratory cycle smooth `s(insp_rel_inded)`."
# A function that returns PPV given a smooth and an intercept
calc_PPV <- function(smooth, intercept) {
min_PP <- min(smooth)
max_PP <- max(smooth)
(max_PP - min_PP) / unname(intercept)
}
PPV_samples <- insp_smooth_samples$value %>%
split(insp_smooth_samples$draw) %>%
sapply(calc_PPV, intercept = coef(PP_gam)[1])
PPV_95 <- quantile(PPV_samples, probs = c(0.025, 0.975))
ggplot(data.frame(PPV = PPV_samples), aes(x=PPV)) +
geom_histogram() +
geom_vline(aes(xintercept = PPV_est, color = "Estimate"),
data = data.frame()) +
geom_vline(aes(xintercept = PPV_95, color = "95% confidence interval"),
data = data.frame()) +
scale_x_continuous(labels = scales::label_percent())
sample_cvp <- readRDS("sample_CVP.RDS")
head(sample_cvp$cvp)
#| fig.cap = "Sample data for CVP model."
plot_cvp_full <- ggplot(sample_cvp$cvp, aes(time, CVP)) +
annotate("rect", xmin = sample_cvp$fluid_start, xmax = sample_cvp$fluid_end,
ymin = -Inf, ymax = Inf,
fill = alpha("blue", 0.4)) +
annotate("rect", xmin = sample_cvp$fluid_start-30, xmax = sample_cvp$fluid_start,
ymin = -Inf, ymax = Inf,
fill = alpha("green", 0.4)) +
geom_line() +
labs(title = "Full sample",
subtitle = "Blue area: administration of 250 ml fluid
Green area: section used to fit GAM")
plot_cvp_short <- ggplot(sample_cvp$cvp, aes(time, CVP)) +
geom_line() +
coord_cartesian(xlim = c(sample_cvp$fluid_start-30, sample_cvp$fluid_start)) +
geom_vline(aes(xintercept = time), color = "red",
data = sample_cvp$insp_start) +
geom_vline(aes(xintercept = time), color = "blue",
data = sample_cvp$qrs) +
labs(title = "Green area",
subtitle = "Blue lines: QRS-complexes
Red lines: inspiration start")
plot_cvp_full/plot_cvp_short
#| fig.cap = "ECG recording (30 seconds) aligned by QRS complexes."
sample_cvp$ecg %>%
add_time_since_event(sample_cvp$qrs$time-0.3, prefix = "pre_qrs") %>%
na.omit() %>%
filter(time < 30) %>%
ggplot(aes(pre_qrs_index-0.3, ECG_II, group = pre_qrs_n)) +
geom_line(alpha = 0.3)
PQ_interval <- 0.150 #seconds
cvp_df <- sample_cvp$cvp %>%
filter(between(time, sample_cvp$fluid_start-30, sample_cvp$fluid_start)) %>%
# QRS time - PQ interval = P wave time.
add_time_since_event(sample_cvp$qrs$time - PQ_interval, prefix = "cardiac") %>%
add_time_since_event(sample_cvp$insp_start$time, prefix = "insp")
head(cvp_df)
#| fig.cap = "Different visualizations of the data used for the CVP model."
cvp_time <- ggplot(cvp_df, aes(time, CVP)) +
geom_line() +
labs(title="Continuous time")
cvp_insp <- ggplot(cvp_df, aes(insp_rel_index, CVP, group = insp_n)) +
geom_line() +
labs(title="Respiratory cycle (relative)")
cvp_p <- ggplot(cvp_df, aes(cardiac_index, CVP, group = cardiac_n)) +
geom_line() +
labs(title="Cardiac cycle (seconds since P wave")
cvp_time / (cvp_insp + cvp_p)
gam_cvp <- bam(
CVP ~
s(cardiac_index, bs = "cr", k = 40) +
# The respiratory cycle effect is not really that smooth, as it has a sharp
# drop at start-expiration. There are different ways to allow this, including
# fitting separate smooths for inspiration and expiration or using and adaptive
# smooth (bs = "ad").
# Here we simply add plenty of knots.
s(insp_rel_index, bs = "cc", k = 30) +
# We create the interaction smooth with ti() instead of te() because the main
# effects, s(cardiac_index) and s(insp_rel_index), are also present in the model.
ti(
cardiac_index,
insp_rel_index,
bs = c("cr", "cc"),
k = c(40, 30),
sp = c(0.2, 2) # 40 x 30 knots makes a highly flexible plane,
# that will often overfit the data. By fixing the smoothing parameters
# we can force the interaction effect to be more smooth.
) +
s(time, bs = "cr"), # If the detrending smooth captures some of the
# other effects (respiratory or cardiac) it may be necessary to set a high
# fixed smoothing parameter.
knots = list(insp_rel_index = c(0, 1)),
method = "fREML",
data = cvp_df
)
