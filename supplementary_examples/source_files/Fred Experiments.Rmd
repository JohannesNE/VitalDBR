---
title: "tests"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

```{r}
install.packages('Rcpp')
library("mgcv")
library("gratia")
library("patchwork")
library("accelerometry")
library("dplyr")
library("ggplot2")
```

```{r}
sample_pp <- readRDS("sample_PP.RDS")

head(sample_pp)

dim(sample_pp$abp)
```

```{r}
sample_pp$abp[2]
```



```{r}

# Arterial blood pressure along with red, vertical lines for inspiration start (starts breathing)

# WE HAVE TO MAKE AN ALGORITHM FOR FINDING THESE INSPIRATION STARTS OURSELVES FROM AWP AIRWAY PRESSURE

abp_plot <- ggplot(sample_pp$abp, aes(time, ABP)) +
  geom_line() +
  geom_vline(aes(xintercept = time), color = "red",
             data = sample_pp$insp_start)
abp_plot
```



```{r}

# Function to find the heart beats (+ systolic and diastolic pressure) from the data visualized above

source("functions.R")
beats <- find_abp_beats(sample_pp$abp)
head(beats)
```

```{r}

# Plot from before with systolic and diastolic pressure

abp_plot +
geom_point(aes(x = time,
y = dia,
colour = "diastole"),
data = beats) +
geom_point(aes(x = time_systole,
y = sys,
colour = "systole"),
data = beats)
```

```{r}

# Pulse Pressure calculated by systolic - diastolic

pp_plot <- ggplot(beats, aes(time, PP)) +
geom_line() +
geom_point() +
geom_vline(aes(xintercept = time), color = "red",
data = sample_pp$insp_start)
pp_plot
```


```{r}

# We index the beats and find their position in an inspiration
# to lay the groundwork for our cubic spline for the GAM

beats_indexed <- add_time_since_event(beats,
time_events = sample_pp$insp_start$time,
prefix = "insp") %>%
# the first beats are earlier than the first inspiration and
# therefore have `insp_rel_index = NA`. We remove these.
na.omit()
# Show only time and the four newly added columns. The other columns from `beats`
# are also in `beats_indexed`.
head(beats_indexed %>% select(-(dia:.noise_pos_after_sys)))
```


```{r}

# Plot the Pulse Pressures of every inspiration

pp_plot_color <- ggplot(beats_indexed, aes(time, PP)) +
geom_line() +
# insp_n is a unique (consecutive) number for each respiratory cycle
geom_point(aes(color = as.factor(insp_n)), show.legend = FALSE) +
geom_vline(aes(xintercept = time), color = "red",
data = sample_pp$insp_start) +
labs(title = "Pulse pressure",
subtitle = "by time. Color indicate respiratory cycle")
pp_insp_plot <- ggplot(beats_indexed,
aes(
insp_rel_index,
PP,
group = as.factor(insp_n),
color = as.factor(insp_n)
)
) +
geom_line(alpha = 0.3, show.legend = FALSE) +
# insp_n is a unique (consecutive) number for each respiratory cycle
geom_point(aes(color = as.factor(insp_n)), show.legend = FALSE) +
labs(subtitle = "by position in the respiratory cycle")
pp_plot_color + pp_insp_plot + plot_layout(widths = c(2,1))
```


```{r}

# Med PP og time kan vi danne 

PP_data <- select(beats_indexed, PP, time, insp_rel_index)
head(PP_data)
```


```{r}
PP_gam <- gam(
# The first parameter to the gam() function is the model specification,
# supplied using formula notation:
PP ~ # Left of the tilde (~) is our dependent variable PP
# Right of the tilde is our independent variables.
# Define a smooth function of insp_rel_index.
s(insp_rel_index,
k = 15, # 15 knots.
bs = "cc" # The basis is a cyclic cubic spline
) +
# Define a smooth function of time
s(time,
bs = "cr" # The basis is a natural cubic spline.
# default k is 10. This will be fine here.
),
# We can specify the positions of the knots for each smooth.
# If only two knots are specified for a cyclic spline, these will
# set the positions of the limiting knot(s). The remaining knots will
# be positioned automatically (at quantiles).
knots = list(insp_rel_index = c(0,1)),
# We use restricted maximum likelihood (REML) to fit the optimal smoothing parameter.
# This is often the best choice, but not the default.
method = "REML",
data = PP_data
)


draw(PP_gam, residuals = TRUE)
```


```{r}
coef(PP_gam)[1]
```


```{r}
PP_pred <- mutate(PP_data, pred = predict(PP_gam))
ggplot(PP_pred, aes(x=time)) +
geom_line(aes(y=PP, color = "Observed")) +
geom_point(aes(y=PP, color = "Observed")) +
geom_point(aes(y=pred, color = "Predicted"))
```


```{r}
PP_newdata <- tibble(
# create 200 points from 0 to 30 to get a smooth line
time = seq(0, 30, length.out = 200)) %>%
# index each new time to our existing vector of inspiration times
add_time_since_event(sample_pp$insp_start$time, prefix = "insp") %>%
na.omit()
PP_interpolate <- bind_cols(
PP_newdata,
predict(PP_gam,
newdata = PP_newdata,
# in addition to the predictions (fit) also return the standard error
# (se.fit) for each prediction. This makes predict return a named list,
# that we can simply bind to our data frame.
se.fit = TRUE)
)
ggplot(PP_interpolate, aes(x=time)) +
geom_ribbon(aes(ymin = fit - 1.96*se.fit,
ymax = fit + 1.96*se.fit,
fill = "Predicted (95% CI)")) +
geom_line(aes(y = fit)) +
geom_point(aes(y=PP, color = "Observed"), data = PP_data) +
scale_fill_manual(values = "skyblue")
```


```{r}
insp_rel_index_smooth <- smooth_estimates(PP_gam,
smooth = "s(insp_rel_index)",
n=100)
min_PP <- min(insp_rel_index_smooth$est)
max_PP <- max(insp_rel_index_smooth$est)
intercept_PP <- coef(PP_gam)[1]
PPV_est <- (max_PP - min_PP) / intercept_PP
sprintf("PPV is %.1f%%", PPV_est*100)
```


```{r}
set.seed(1)
insp_smooth_samples <- smooth_samples(PP_gam, term = "s(insp_rel_index)", n = 5000)
ggplot(insp_smooth_samples %>% filter(draw <= 50), aes(.x1, value, group = draw)) +
geom_line(alpha = 0.1) +
labs(x="insp_rel_index")
# A function that returns PPV given a smooth and an intercept
calc_PPV <- function(smooth, intercept) {
min_PP <- min(smooth)
max_PP <- max(smooth)
(max_PP - min_PP) / unname(intercept)
}
PPV_samples <- insp_smooth_samples$value %>%
split(insp_smooth_samples$draw) %>%
sapply(calc_PPV, intercept = coef(PP_gam)[1])
PPV_95 <- quantile(PPV_samples, probs = c(0.025, 0.975))
ggplot(data.frame(PPV = PPV_samples), aes(x=PPV)) +
geom_histogram() +
geom_vline(aes(xintercept = PPV_est, color = "Estimate"),
data = data.frame()) +
geom_vline(aes(xintercept = PPV_95, color = "95% confidence interval"),
data = data.frame()) +
scale_x_continuous(labels = scales::label_percent())
```











# LOAD DATA    LOAD DATA    LOAD DATA    LOAD DATA    LOAD DATA    LOAD DATA    LOAD DATA    LOAD DATA     



```{r}
library(httr)
library(httr2)
library(curl)
library(R.utils)
library(data.table)    
library(dplyr)
#install.packages("tidyverse")
library(tidyverse)
```



```{r}


  # Brugeren inputter én eller flere tnames i load_case, f.eks. c(BIS/EMG, Primus/INSP_DES, Solar8000/BT)
  # Brugeren inputter også ét (og kun ét) case id. f.eks. "17"
  # Funktionen samler nu alle "tids" forbundet med de forskellige tnames i case 1. ( i det her tilfælde 3 stk.)
  # Funktionen kalder nu load_trks(tids), der kalder load_trk(tid) som kalder load vdb (der henter fra api) på alle tid i tids
  # dermed bliver der returnet 3 tidsserier c(BIS/EMG, Primus/INSP_DES, Solar8000/BT), der alle tilhører case 17


load_VDB <- function(file_url) {
  con <- gzcon(url(file_url))
  txt <- readLines(con)
  return(read.csv(textConnection(txt)))
}
load_trk <- function(tid){
  start <- "https://api.vitaldb.net/"
  end <- ".csv.gz"
  # start + tid + end
  url <- paste(start, tid, end, sep="")
  print(load_VDB(url))
  return(load_VDB(url))
}
load_trks <- function(tids){
  data <- data.frame()
  index <- 1
  for (i in 1:nrow(tids)){
    load_trk(tids[i,])
    index <- index+1
  }
}
load_case <- function(tnames, caseid){
  tracks <- load_VDB("https://api.vitaldb.net/trks.csv.gz")
  tracks <- tracks[tracks$caseid == caseid,]
  tids <- data.frame(col = rep(NA, length(tnames)))
  index <- 1
  for (tname in tnames){
    tids$col[index] <- (tracks[tracks$tname == tname,])$tid
    index <- index+1
  }
  load_trks(tids)
}
load_case(c("BIS/EMG","Solar8000/BT"), 1)
```

```{r}
#url <- "https://api.vitaldb.net/afd182c102c5af625d3f217280b3766d453d9e3f.csv.gz"
url2 <- "https://api.vitaldb.net/trks.csv.gz"
url3 <- "https://api.vitaldb.net/cases.csv.gz"
url4 <- "https://api.vitaldb.net/labs.csv.gz"
#loading track data
trackdata <- load_VDB(url)
# loading tracks
tracks <- load_VDB(url2)
# loading cases
cases <- load_VDB(url3)
# loading labs
labs <- load_VDB(url4)
```

```{r}
closeAllConnections()
```




