---
title: "S1: Fitting GAMs to medical monitoring data"
author: "Johannes Enevoldsen & Simon Tilma Vistisen"
output:
  pdf_document:
    toc: yes
  html_document: 
    theme: "readable"
    toc: yes
    toc_float: yes
    number_sections: yes
header-includes: \usepackage{underscore}
toc-title: "Table of contents"
---

```{r hidden_setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      #dpi = 150,
                      fig.width = 7,
                      fig.height = 5,
                      fig.retina = 2,
                      out.width = "70%",
                      fig.align = "center"
                      )

knitr::opts_template$set(wide = list(
  fig.height=2, fig.width=10, out.width = "100%"
), 
  nooutput = list(fig.height=1, fig.width=1, out.width = "100%") # keep cache with default opt change
)
```

```{css, echo=FALSE}
h1 {
  margin-top: 2em;
}
h2 {
  margin-top: 1.5em;
}
div.figure {
  margin-top: 2em;
  margin-bottom: 3em;
}
```

------------

The following are a few examples on how to fit and work with generalized additive models (GAMs) in R using *[mgcv](https://CRAN.R-project.org/package=mgcv)*.

# Packages

Packages used in this demonstration can be installed from CRAN using `install.packages("package name")`.

```{r packages, message=FALSE}
library(mgcv) # fitting GAMs 
library(gratia) # visualising and working with GAMs
library(dplyr) # working with data-frames
library(ggplot2) # plotting
library(patchwork) # combining plots

# only used for heart beat detection (dependencies of `find_abp_beats()`)
# install.packages("accelerometry")
# install.packages("purrr")

theme_set(theme_minimal()) # Change the default plotting theme
```

# Pulse pressure model

## Load data

The first example corresponds to the model shown in Figure 2 in the paper.

We use a 30 second recording of arterial blood pressure (ABP). The sample data is structured as a list. It includes ABP `sample_pp$abp` and the start time of each inspiration `sample_pp$insp_start`. 

```{r}
sample_pp <- readRDS("sample_PP.RDS")
```

The ABP is stored as a data frame with a time column and a pressure column. The time is in seconds, the sample rate is 125 Hz, and the pressure unit is mmHg.

```{r}
head(sample_pp$abp)
```

The timing of inspirations is a data frame with a time column that indicates when a new inspiration starts.

```{r}
head(sample_pp$insp_start)
```

We can visualize the two data frames together.

```{r opts.label='wide' }
#| fig.cap = "Arterial blood pressure (ABP). Red lines indicate inspiration start."
abp_plot <- ggplot(sample_pp$abp, aes(time, ABP)) +
  geom_line() +
  geom_vline(aes(xintercept = time), color = "red",
             data = sample_pp$insp_start) 

abp_plot
```

## Detect heart beats

We now detect individual heart beats from the ABP waveform. A function, `find_abp_beats()`, is shared in the file `functions.R`. It takes an ABP waveform and returns a data frame of individual beats. The data frame contains the following columns (plus a few more):

- `time`: timing of the diastole (negative peak). This marks the beginning of a beat. 
- `dia`: diastolic pressure. 
- `time_systole`: timing of the systole (positive peak).
- `sys`: the following systolic pressure.
- `PP`: pulse pressure (`sys` - `dia`)
- `beat_len`: length of the beat (`time` - `lead(time)`)

```{r}
source("functions.R")

beats <- find_abp_beats(sample_pp$abp)
head(beats)
```

We can add this information to the previous plot.

```{r opts.label='wide' }
#| fig.cap = "Beats are detected using `find_abp_beats()`."
abp_plot + 
  geom_point(aes(x = time,
                 y = dia,
                 colour = "diastole"), 
             data = beats) +
  geom_point(aes(x = time_systole, 
                 y = sys,
                 colour = "systole"), 
             data = beats) 
```

For this model, we are only interested in the pulse pressure (PP) of each heart beat.

```{r opts.label='wide' }
#| fig.cap = "Pulse pressure (PP) of each heart beat."
pp_plot <- ggplot(beats, aes(time, PP)) +
  geom_line() + 
  geom_point() +
  geom_vline(aes(xintercept = time), color = "red",
             data = sample_pp$insp_start)

pp_plot
```

Before we can fit the model, we need to calculate the position of each beat in the respiratory cycle. `functions.R` contain `add_time_since_event()`, that takes a data frame with a time column (here `beats`) and a vector of times corresponding to some event (here the timing of each inspiration start: `sample_pp$insp_start$time`) and returns the data frame with new columns indication the timing of each observation (beat) relative to the most recent event. The new columns are:

- `insp_index`: Time since the latest inspiration start.
- `insp_n`: Respiratory cycle number.
- `insp_cycle_len`: Length of the respiratory cycle.
- `insp_rel_index`: The relative position of the beat in the respiratory cycle (`insp_index` / `insp_cycle_len`).


```{r}
beats_indexed <- add_time_since_event(beats, 
                                      time_events = sample_pp$insp_start$time, 
                                      prefix = "insp") %>% 
  # the first beats are earlier than the first inspiration and 
  # therefore have `insp_rel_index = NA`. We remove these.
  na.omit() 

# Show only time and the four newly added columns. The other columns from `beats`  
# are also in `beats_indexed`.
head(beats_indexed %>% select(-(dia:.noise_pos_after_sys)))
```

This lets us show each beat by its position in the respiratory cycle.

```{r fig.height=3, fig.width=10, out.width = '100%'}
#| fig.cap = "Pulse pressure indexed to the respiratory cycle."
pp_plot_color <- ggplot(beats_indexed, aes(time, PP)) +
  geom_line() + 
  # insp_n is a unique (consecutive) number for each respiratory cycle
  geom_point(aes(color = as.factor(insp_n)), show.legend = FALSE) + 
  geom_vline(aes(xintercept = time), color = "red",
             data = sample_pp$insp_start) +
  labs(title = "Pulse pressure", 
       subtitle = "by time. Color indicate respiratory cycle")

pp_insp_plot <- ggplot(beats_indexed, 
                       aes(
                         insp_rel_index, 
                         PP,
                         group = as.factor(insp_n),
                         color = as.factor(insp_n)
                         )
                       ) +
  geom_line(alpha = 0.3, show.legend = FALSE) + 
  # insp_n is a unique (consecutive) number for each respiratory cycle
  geom_point(aes(color = as.factor(insp_n)), show.legend = FALSE) +
  labs(subtitle = "by position in the respiratory cycle")

pp_plot_color + pp_insp_plot + plot_layout(widths = c(2,1))
```

We now have the variables we need to fit the model. For clarity, we select only the variables we need.

```{r}
PP_data <- select(beats_indexed, PP, time, insp_rel_index)

head(PP_data)
```

## Fit and visualize the GAM

To fit the model, we use the `gam()` function from `mgcv`. 

```{r}
PP_gam <- gam(
  # The first parameter to the gam() function is the model specification, 
  # supplied using formula notation: 
  PP ~ # Left of the tilde (~) is our dependent variable PP
    
    # Right of the tilde is our independent variables.
    # Define a smooth function of insp_rel_index.
    s(insp_rel_index, 
      k = 15, # 15 knots.
      bs = "cc" # The basis is a cyclic cubic spline
      ) +
    # Define a smooth function of time
    s(time, 
      bs = "cr" # The basis is a natural cubic spline.
      # default k is 10. This will be fine here.
      ),
  
  # We can specify the positions of the knots for each smooth. 
  # If only two knots are specified for a cyclic spline, these will
  # set the positions of the limiting knot(s). The remaining knots will 
  # be positioned automatically (at quantiles).
  knots = list(insp_rel_index = c(0,1)),
  
  # We use restricted maximum likelihood (REML) to fit the optimal smoothing parameter.
  # This is often the best choice, but not the default.
  method = "REML",
  
  data = PP_data
)
```

Now, plot the model using `gratia::draw()` (or `plot()`). Adding partial residuals is a simple way to visualize how the well model fits observed data, and to identify systematic errors. Partial residuals are the model residuals + the specific smooth effect in the plot.

```{r fig.height=3.5, fig.width=7}
#| fig.cap = "Smooth effects of the pulse pressure GAM."
draw(PP_gam, 
     residuals = TRUE)
```

In addition to the two smooth effects, the model also has a constant/intercept, which is not visualized in the plots above. The intercept is the mean PP.

```{r}
coef(PP_gam)[1]
```

Predictions (or fit) can be calculated as

$$
\hat{PP} = Intercept + s(\text{insp_rel_index}) + s(\text{time}).
$$

We can use `predict()` to calculate model predictions. If we only pass the GAM, it will make predictions using the observed independent variables we used to fit the model. We can add these predictions as a new column to our original dataset.

> When `predict()` is called on a GAM (an object of class "gam"), the specific method `predict.gam()` is used. See `?predict.gam()` for help.

```{r opts.label='wide' }
#| fig.cap = "Observed and predicted pulse pressure."
PP_pred <- mutate(PP_data, pred = predict(PP_gam))

ggplot(PP_pred, aes(x=time)) +
  geom_line(aes(y=PP, color = "Observed")) +
  geom_point(aes(y=PP, color = "Observed")) +
  geom_point(aes(y=pred, color = "Predicted"))

```

We can use the `newdata` parameter in `predict()` to interpolate prediction between our observations (it rarely makes sense to extrapolate a spline fit).

```{r opts.label='wide'}
#| fig.cap = "Observed and predicted pulse pressure, including predictions between observations."

PP_newdata <- tibble(
  # create 200 points from 0 to 30 to get a smooth line
  time = seq(0, 30, length.out = 200)) %>% 
  # index each new time to our existing vector of inspiration times
  add_time_since_event(sample_pp$insp_start$time, prefix = "insp") %>% 
  na.omit()

PP_interpolate <- bind_cols(
  PP_newdata,
  predict(PP_gam, 
          newdata = PP_newdata, 
          # in addition to the predictions (fit) also return the standard error 
          # (se.fit) for each prediction. This makes predict return a named list,
          # that we can simply bind to our data frame.
          se.fit = TRUE) 
)

ggplot(PP_interpolate, aes(x=time)) +
  geom_ribbon(aes(ymin = fit - 1.96*se.fit,
                  ymax = fit + 1.96*se.fit,
                  fill = "Predicted (95% CI)")) +
  geom_line(aes(y = fit)) +
  geom_point(aes(y=PP, color = "Observed"), data = PP_data) +
  scale_fill_manual(values = "skyblue")
```

## Calculate pulse pressure variation

We can calculate pulse pressure variation (PPV) from this model using the formula 

$$
PPV = \frac{maximum(s(\text{insp_rel_index})) - minimum(s(\text{insp_rel_index}))}{Intercept}.
$$

To find the the extreme of the smooth, we can generate a grid of predictions using only the one smooth term `s(insp_rel_index)`. We could use `predict(type="terms")` but `gratia::smooth_estimates()` conveniently returns the values of the smooth over the original range of the independent variable (here `insp_rel_index`).

```{r}
insp_rel_index_smooth <- smooth_estimates(PP_gam, 
                                          smooth = "s(insp_rel_index)", 
                                          n=100)
min_PP <- min(insp_rel_index_smooth$est)
max_PP <- max(insp_rel_index_smooth$est)
intercept_PP <- coef(PP_gam)[1]
PPV_est <- (max_PP - min_PP) / intercept_PP

sprintf("PPV is %.1f%%", PPV_est*100)
```

This PPV is an estimate from the model. We should also report the uncertainty. `mgcv` lets us sample parameters from the posterior distribution of the model similarly to from a Bayesian model (see Gavin Simpson's (author of `gratia`) [answer on StackOverflow](https://stats.stackexchange.com/questions/190348/can-i-use-bootstrapping-to-estimate-the-uncertainty-in-a-maximum-value-of-a-gam) for an in-depth example of how this can be done). Here we need posterior samples of a smooth, and, conveniently, `gratia::smooth_samples()` does just that. For each sampled smooth, we can calculate PPV, and use the samples of PPVs to calculate a confidence interval for PPV (this approach neglects that the model intercept is also an estimate, but since the standard error for the intercept is very small, this has negligible effect on the width of the confidence interval).

```{r}
#| fig.cap = "Plot of 50 of the 5000 sampled smooths from the posterior distribution of the respiratory cycle smooth `s(insp_rel_inded)`."
set.seed(1)
insp_smooth_samples <- smooth_samples(PP_gam, term = "s(insp_rel_index)", n = 5000)

ggplot(insp_smooth_samples %>% filter(draw <= 50), aes(.x1, value, group = draw)) +
  geom_line(alpha = 0.1) +
  labs(x="insp_rel_index")
```

```{r}
#| fig.cap = "Histogram of PPVs calculated from each of the 5000 sampled smooths from the posterior distribution of the respiratory cycle smooth `s(insp_rel_inded)`."
# A function that returns PPV given a smooth and an intercept
calc_PPV <- function(smooth, intercept) {
  min_PP <- min(smooth)
  max_PP <- max(smooth)
  (max_PP - min_PP) / unname(intercept)
}

PPV_samples <- insp_smooth_samples$value %>% 
  split(insp_smooth_samples$draw) %>% 
  sapply(calc_PPV, intercept = coef(PP_gam)[1]) 

PPV_95 <- quantile(PPV_samples, probs = c(0.025, 0.975))

ggplot(data.frame(PPV = PPV_samples), aes(x=PPV)) +
  geom_histogram() +
  geom_vline(aes(xintercept = PPV_est, color = "Estimate"), 
             data = data.frame()) + 
  geom_vline(aes(xintercept = PPV_95, color = "95% confidence interval"), 
             data = data.frame()) +
  scale_x_continuous(labels = scales::label_percent())
```

# Central venous pressure

## Load data

This example example corresponds to the model shown in Figure 5 in the paper.

We use a section of a recording of central venous pressure (CVP) `sample_cvp$cvp`. The sample data is structured as a list. In addition to CVP, it and also includes the start time of each inspiration `sample_cvp$insp_start` and of each QRS-complex `sample_cvp$qrs` and the interval in which 250 ml fluid is administered (`sample_cvp$fluid_start` to `sample_cvp$fluid_end`). 

```{r}
sample_cvp <- readRDS("sample_CVP.RDS")
```

The CVP is stored as a data frame with a time column and a pressure column. The time is in seconds, the sample rate is 125 Hz and the pressure unit is mmHg.

```{r}
head(sample_cvp$cvp)
```

```{r opts.label='wide', fig.height=4}
#| fig.cap = "Sample data for CVP model."
plot_cvp_full <- ggplot(sample_cvp$cvp, aes(time, CVP)) +
  annotate("rect", xmin = sample_cvp$fluid_start, xmax = sample_cvp$fluid_end,
            ymin = -Inf, ymax = Inf, 
            fill = alpha("blue", 0.4)) +
  annotate("rect", xmin = sample_cvp$fluid_start-30, xmax = sample_cvp$fluid_start,
            ymin = -Inf, ymax = Inf, 
            fill = alpha("green", 0.4)) +
  geom_line() +
  labs(title = "Full sample",
       subtitle = "Blue area: administration of 250 ml fluid
Green area: section used to fit GAM")

plot_cvp_short <- ggplot(sample_cvp$cvp, aes(time, CVP)) +
  geom_line() +
  coord_cartesian(xlim = c(sample_cvp$fluid_start-30, sample_cvp$fluid_start)) +
  geom_vline(aes(xintercept = time), color = "red",
             data = sample_cvp$insp_start) +
  geom_vline(aes(xintercept = time), color = "blue",
             data = sample_cvp$qrs) +
  labs(title = "Green area",
       subtitle = "Blue lines: QRS-complexes
Red lines: inspiration start")

plot_cvp_full/plot_cvp_short
```

We want to fit the model

$$ 
CVP = f(pos_{cardiac}) + f(pos_{ventilation}) + f(pos_{cardiac},\ pos_{ventilation}) + f(t_{total}) + \epsilon.
$$

First, we need to calculate each CVP sample's position in both the cardiac and respiratory cycles. For the respiratory cycle, we will fit a cyclic spline based on the relative position (as in the pulse pressure example above). For the cardiac cycle, we cannot simply use a cyclic spline, as the cycles vary in length. We could use a cyclic spline based on the relative position in the cardiac cycle of a CVP sample, but that would assume that the CVP waveform of a long cardiac cycle is simply a linearly stretched version of a short cycle. Instead we assume that the cardiac cycle effect depends on the time since the P-wave (initiation of atrial contraction). Instead of trying to detect P-waves from the ECG, we assume that they appear a constant interval before the QRS complex.

To find the PQ interval, we align 30 seconds of ECG recording by the detected QRS complexes. 

```{r}
#| fig.cap = "ECG recording (30 seconds) aligned by QRS complexes."
sample_cvp$ecg %>% 
  add_time_since_event(sample_cvp$qrs$time-0.3, prefix = "pre_qrs") %>% 
  na.omit() %>% 
  filter(time < 30) %>% 
  ggplot(aes(pre_qrs_index-0.3, ECG_II, group = pre_qrs_n)) +
  geom_line(alpha = 0.3)
```

We can see that the P-wave starts ~150 ms before the QRS complex.

In this example we will fit a GAM to the last 30 seconds before fluid administration starts. We filter the CVP data to the relevant interval and add each sample's position in both the cardiac cycle (starting at the P-wave) and the respiratory cycle.

```{r}
PQ_interval <- 0.150 #seconds

cvp_df <- sample_cvp$cvp %>% 
  filter(between(time, sample_cvp$fluid_start-30, sample_cvp$fluid_start)) %>% 
  # QRS time - PQ interval = P wave time.
  add_time_since_event(sample_cvp$qrs$time - PQ_interval, prefix = "cardiac") %>% 
  add_time_since_event(sample_cvp$insp_start$time, prefix = "insp")
  
head(cvp_df)
```

Before fitting the model, we can visualize (individually) the three effects we subsequently want to model (collectively): continuous time, respiratory cycle and heart cycle.

```{r}
#| fig.cap = "Different visualizations of the data used for the CVP model."
cvp_time <- ggplot(cvp_df, aes(time, CVP)) +
  geom_line() +
  
  labs(title="Continuous time")

cvp_insp <- ggplot(cvp_df, aes(insp_rel_index, CVP, group = insp_n)) +
  geom_line() +
  labs(title="Respiratory cycle (relative)")

cvp_p <- ggplot(cvp_df, aes(cardiac_index, CVP, group = cardiac_n)) +
  geom_line() +
  labs(title="Cardiac cycle (seconds since P wave")

cvp_time / (cvp_insp + cvp_p)
```

## Fit and visualize the GAM

Now, we are ready to fit the model. This time we use `bam()` which is like `gam()`, but optimized for large datasets. First we fit the model without correcting for autocorrelation of the residuals. The next section will demonstrate how to correct for autocorrelation. 

```{r, opts.label='nooutput', cache=TRUE}
gam_cvp <- bam( 
      CVP ~ 
        s(cardiac_index, bs = "cr", k = 40) +
        # The respiratory cycle effect is not really that smooth, as it has a sharp
        # drop at start-expiration. There are different ways to allow this, including
        # fitting separate smooths for inspiration and expiration or using and adaptive
        # smooth (bs = "ad").
        # Here we simply add plenty of knots.
        s(insp_rel_index, bs = "cc", k = 30) +
        # We create the interaction smooth with ti() instead of te() because the main 
        # effects, s(cardiac_index) and s(insp_rel_index), are also present in the model.  
        ti(
          cardiac_index,
          insp_rel_index,
          bs = c("cr", "cc"),
          k = c(40, 30),
          sp = c(0.2, 2) # 40 x 30 knots makes a highly flexible plane, 
          # that will often overfit the data. By fixing the smoothing parameters
          # we can force the interaction effect to be more smooth.
        ) +
        s(time, bs = "cr"), # If the detrending smooth captures some of the
        # other effects (respiratory or cardiac) it may be necessary to set a high 
        # fixed smoothing parameter.
        knots = list(insp_rel_index = c(0, 1)),
        method = "fREML",
        data = cvp_df
    )
```

Visualize the smooth effects of the model.

```{r}
#| fig.cap = "Smooth effects of the CVP GAM."
gratia::draw(gam_cvp, residuals = TRUE, rug = FALSE)
```

The model intercept, the mean CVP, is not visualized in the plots above. 

```{r}
coef(gam_cvp)[1]
```

We can visualize how well our model fits our observed CVP.

```{r, opts.label='wide', fig.height=3}
#| fig.cap = "Observed, predicted and residual CVP"
cvp_df_pred <- mutate(cvp_df,
                             pred = predict(gam_cvp),
                             resid = resid(gam_cvp))

cvp_df_pred %>% 
  ggplot(aes(time, CVP)) +
  geom_line() +
  geom_line(aes(y = pred), color = "red") +
  geom_line(aes(y = resid), color = "orange") 
```

In the paper's Figure 6 the fit is visualized as a singe contour plot that sums all the effects except detrending (continuous time). Here is a similar visualization.

```{r}
#| fig.cap = "Combined visualization of the CVP GAM, excluding the detrending smooth."
# Create a new dataset containing a grid of 
# `cardiac_index` and `insp_rel_index` to generate predictions for.

# Use a grid with a resolution of 100x100.
cvp_contour_data <- expand.grid(
  # The longest 
  cardiac_index = seq(0, 0.7, length.out = 100), 
  insp_rel_index = seq(0, 1, length.out = 100),
  time = 999) # We will not use `time` in our prediction, but predict.gam()
              # expects the variable to be present.


cvp_contour_data$CVP_pred <- predict(gam_cvp, 
                                     newdata = cvp_contour_data, 
                                     exclude = "s(time)")

ggplot(cvp_contour_data, aes(x = cardiac_index, y=insp_rel_index, z = CVP_pred)) + 
  geom_contour_filled(binwidth = 1) +
  guides(fill = guide_colorsteps(barheight = 15, title = "CVP"))
```

## Autocorrelated residuals

One assumption of a GAM is that the residuals are independent. This will rarely be fulfilled when modelling high resolution waveforms. We can investigate the correlation of the residuals using `acf()`.

```{r}
auto_corr_gam_cvp <- acf(residuals(gam_cvp))
```
This plot shows the correlation of a residual with the residual 0 to 35 points later. Zero points later correspond to the residual itself, and will always be 1. `bam()` allows modelling the residual errors as an AR(1) model (each residual ($\epsilon_t$) is some proportion (rho) of the previous residual + random error: $\epsilon_t = rho * epsilon_{t-1} + w_t, w_t \sim normal(0, \sigma)$)). `bam()` allows us to specify a fixed AR(1) correlation coefficient with the `rho` parameter, but we have to tune it manually. A good guess is the first-order autocorrelation from a model not accounting for autocorrelation (here `gam_cvp`):

```{r}

auto_corr_gam_cvp$acf[2] # $acf[1] is the unlagged correlation (= 1)
```

The AR(1) model implies that the correlation between residuals drops exponentially with the distance between them. Our CVP waveform has a sample rate of 125 Hz, so a correlation coefficient of 0.9 per sample corresponds to the following relation between correlation and time:

```{r}
time_ms <- 0:500
correlation <- 0.9^((time_ms/1000)*125)

plot(time_ms, correlation, type = "l", 
     main = "Expected autocorrelation given the AR(1) model with rho = 0.9 at 125 Hz")
```

With this model, we expect very little correlation between residuals more than 200 ms apart.

We can use this to fit a GAM with autocorrelated residuals as suggested by van Rij et al, 2019 (https://doi.org/10.1177/2331216519832483).

```{r, opts.label='nooutput', cache=TRUE}
# The model i identical to gam_cvp except for the rho parameter.
gam_cvp_AR <- bam( 
      CVP ~ 
        s(cardiac_index, bs = "cr", k = 40) +
        s(insp_rel_index, bs = "cc", k = 30) +
        ti(
          cardiac_index,
          insp_rel_index,
          bs = c("cr", "cc"),
          k = c(40, 30),
          sp = c(0.2, 2)
        ) +
        s(time, bs = "cr"), 
        knots = list(insp_rel_index = c(0, 1)),
        method = "fREML",
        rho = 0.9, # correlation coefficient for AR(1) model of the residuals
        data = cvp_df
    )
```

```{r}
gratia::draw(gam_cvp_AR, residual = TRUE, rug = FALSE)
```

The autocorrelation-corrected residuals are stored in `gam_cvp_AR$std.rsd`. Again, we can use `acf()` to visualize the residual autocorrelation. 

```{r}
acf(gam_cvp_AR$std.rsd)
```

We can see that this has markedly reduced the autocorrelation in the residuals. The rho chosen with this approach is not guaranteed to be optimal. It is possible to search for the value of rho minimizing the REML-score, but this is computationally expensive as it requires refitting the model for each rho. For detail about estimating autocorrelation of residuals, see Simpson, 2018 (https://doi.org/10.3389/fevo.2018.00149).

## Other common challenges

The CVP waveform in the window 30 second earlier is a bit more noisy. We will use that section of data to demonstrate a few common challenges.

```{r}
#| fig.cap = "Different visualizations of the noisy data used for the second CVP model."
cvp_df_noise <- sample_cvp$cvp %>% 
  filter(between(time, sample_cvp$fluid_start-60, sample_cvp$fluid_start-30)) %>% 
  # QRS time - PQ interval = P wave time.
  add_time_since_event(sample_cvp$qrs$time - PQ_interval, prefix = "cardiac") %>% 
  add_time_since_event(sample_cvp$insp_start$time, prefix = "insp")
  

cvp_time <- ggplot(cvp_df_noise, aes(time, CVP)) +
  geom_line()

cvp_insp <- ggplot(cvp_df_noise, aes(insp_rel_index, CVP, group = insp_n)) +
  geom_line()

cvp_p <- ggplot(cvp_df_noise, aes(cardiac_index, CVP, group = cardiac_n)) +
  geom_line()

cvp_time / (cvp_insp + cvp_p)
```

In the first iteration, we will use fewer knots in the cardiac smooth.

```{r, opts.label='nooutput', cache=TRUE}
gam_cvp_noise1 <- bam(
      CVP ~ 
        s(cardiac_index, bs = "cr", k = 15) + # only 15 knots
        s(insp_rel_index, bs = "cc", k = 30) + 
        # 
        ti(
          cardiac_index,
          insp_rel_index,
          bs = c("cr", "cc"),
          k = c(15, 30) # only 15 knots in the cardiac dimension
        ) +
        s(time, bs = "cr"),
        knots = list(insp_rel_index = c(0, 1)),
        method = "fREML",
        data = cvp_df_noise
    )
```

```{r}
#| fig.cap = "Smooth effects of the noisy CVP GAM."
gratia::draw(gam_cvp_noise1, residuals = TRUE, rug = FALSE)
```

Here, the interaction smooth clearly overfits the data, and it looks like the cardiac smooth is not flexible enough to match the sharp 'v' peak (the most negative in this sample).

Optimally, the shape of a spline should be limited by the wiggliness penalty (smoothing parameter) and not the number of knots. We can use `gam.check` the see if any splines are limited by their number of knots.

```{r}
old_par = par(mfrow = c(2,2))
gam.check(gam_cvp_noise1)
par(old_par) # reset par
```

In this table, `k'` is the maximum possible degrees of freedom (d.f.) of the smooth. This is one less than the number knots as one d.f. is used to constrain the spline to have a sum of zero (see `?mgcv::identifiability`). For cyclic splines it is two less than `k`, as the two limiting knots are effectively a single knot. `edf` is the effective degrees of freedom after the smoothing penalty. A `k-index` < 1 indicates there is some residual pattern that is not contained in the smooth. If `k-index` is low and `edf` is close to `k'`, the smooth probably has too few knots. On the other hand, too many knots are not a problem (except for the higher computational cost).

We increase `k` for the cardiac smooth and the cardiac dimension in the interaction. To reduce overfitting from the interaction term, we will add a fixed smoothing parameter.

```{r, opts.label='nooutput', cache=TRUE}
gam_cvp_noise2 <- bam(
      CVP ~ 
        s(cardiac_index, bs = "cr", k = 40) +
        s(insp_rel_index, bs = "cc", k = 30) + 
        # 
        ti(
          cardiac_index,
          insp_rel_index,
          bs = c("cr", "cc"),
          k = c(40, 30),
          sp = c(0.2, 2) # fixed smoothing parameters
        ) +
        s(time, bs = "cr"),
        knots = list(insp_rel_index = c(0, 1)),
        method = "fREML",
        data = cvp_df_noise
    )
```

```{r}
#| fig.cap = "Smooth effects of new version the noisy CVP GAM. This time with more knots in the cardiac smooth and fixed smoothing parameters of the interaction smooth."
gratia::draw(gam_cvp_noise2, residuals = TRUE, rug = FALSE)
```
```{r, opts.label='wide', fig.height=3}
cvp_df_noise_pred2 <- mutate(cvp_df_noise,
                             pred = predict(gam_cvp_noise2),
                             resid = resid(gam_cvp_noise2))

ggplot(cvp_df_noise_pred2, aes(time, CVP)) +
  geom_line() +
  geom_line(aes(y = pred), color = "red")+
  geom_line(aes(y = resid), color = "orange")
```

The residuals seem to be mostly random. There is slight repeating pattern: an increase in the residuals one third into each respiratory cycle (also visible in the plot of the `s(insp_rel_index)` smooth). This corresponds to the closing of the ventilator solenoid valve at end-inspiration. The sudden drop in pressure makes the ventilator tubing move and disturb the adjacent CVP line. 

# Session info

Rendered: `r Sys.time()`

```{r session-info, include=TRUE, echo=TRUE}
sessionInfo()
```
