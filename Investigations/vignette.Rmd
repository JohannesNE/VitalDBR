---
title: "asd"
output: html_document
---


```{r}
library(devtools)
install_github('legendenomgeorg/VitalDBR/VitalDBR')
library(VitalDBR)
library(stats)
library(waveformtools)
library(ggplot2)
library(mgcv)
library(dplyr)
```

```{r}
df_art <- VitalDBR::load_case('SNUADC/ART', 1)
df_awp <- VitalDBR::load_case('Primus/AWP', 1)
```


```{r}
start = 10000 # Starter fra sekund "start"
sec = 30 # Varer "sec" sekunder 
```

Subset AWP time series
```{r}
sub_awp <- VitalDBR::subset_data(data = df_awp, seconds = sec, start_sec = start)
sub_awp
plot(sub_awp$Time, sub_awp$Primus.AWP, type='l')
```


```{r}
insp_start <- VitalDBR::get_inspiration_start(sub_awp)
insp_start
```


```{r}
sub_art <- VitalDBR::subset_data(data = df_art, seconds = sec, start_sec = start, filter=TRUE)
waveformtools::dygraph_signal(sub_art, SNUADC.ART, SNUADC.ART_filt)

```

ABP beats
```{r}
beats <- waveformtools::find_abp_beats(sub_art,3,1)[-1,] #skipper lige første row, fordi der ikke er noget pp værdi der

```

```{r}
abp_plot <- ggplot(sub_art, aes(Time, SNUADC.ART_filt)) +
geom_line() +
geom_vline(aes(xintercept = time), color = "red",
data = insp_start)
abp_plot
```


```{r}
abp_plot +
  geom_point(aes(x = time,
    y = dia,
    colour = "diastole"),
    data = beats) +
  geom_point(aes(x = time_systole,
    y = sys,
    colour = "systole"),
    data = beats)
```


```{r}
pp_plot <- ggplot(beats, aes(time, PP)) +
  geom_line() +
  geom_point() +
  geom_vline(aes(xintercept = time), color = "red",
  data = insp_start)
pp_plot
```

```{r}
beats
```




```{r}
beats_indexed <- waveformtools::add_time_since_event(beats, time_event = insp_start$time)
# ann_rel_index starter forfra ved hver inspiration. 
beats_indexed
```

```{r}
pp_plot_color <- ggplot(beats_indexed, aes(time, PP)) +
geom_line() +
# insp_n is a unique (consecutive) number for each respiratory cycle
geom_point(aes(color = as.factor(ann_n)), show.legend = FALSE) +
geom_vline(aes(xintercept = time), color = "red",
data = insp_start) +
labs(title = "Pulse pressure",
subtitle = "by time. Color indicate respiratory cycle")
pp_insp_plot <- ggplot(beats_indexed,
aes(
ann_rel_index,
PP,
group = as.factor(ann_n),
color = as.factor(ann_n)
)
) +
geom_line(alpha = 0.3, show.legend = FALSE) +
# insp_n is a unique (consecutive) number for each respiratory cycle
geom_point(aes(color = as.factor(ann_n)), show.legend = FALSE) +
labs(subtitle = "by position in the respiratory cycle")
pp_plot_color + pp_insp_plot
```
```{r}
PP_data <- beats_indexed[,c(4,1,14)]
head(PP_data)
```



```{r}
PP_gam <- gam(
# The first parameter to the gam() function is the model specification,
# supplied using formula notation:
PP ~ # Left of the tilde (~) is our dependent variable PP
# Right of the tilde is our independent variables.
# Define a smooth function of insp_rel_index.
s(ann_rel_index,
k = 15, # 15 knots.
bs = "cc" # The basis is a cyclic cubic spline
) +
# Define a smooth function of time
s(time,
bs = "cr" # The basis is a natural cubic spline.
# default k is 10. This will be fine here.
),
# We can specify the positions of the knots for each smooth.
# If only two knots are specified for a cyclic spline, these will
# set the positions of the limiting knot(s). The remaining knots will
# be positioned automatically (at quantiles).
knots = list(ann_rel_index = c(0,1)),
# We use restricted maximum likelihood (REML) to fit the optimal smoothing parameter.
# This is often the best choice, but not the default.
method = "REML",
data = PP_data
)
```

```{r}
gratia::draw(PP_gam,
residuals = TRUE)
```


```{r}
coef(PP_gam)[1] # intercept



```



```{r}
PP_pred <- mutate(PP_data, pred = predict(PP_gam, PP_data ))
ggplot(PP_pred, aes(x=time)) +
geom_line(aes(y=PP, color = "Observed")) +
geom_point(aes(y=PP, color = "Observed")) +
geom_point(aes(y=pred, color = "Predicted"))
```



```{r}

PP_newdata <- tibble(
# create 200 points from start to endto get a smooth line
time = seq(start, sec+start, length.out = 200)) %>% 
# index each new time to our existing vector of inspiration times
add_time_since_event(insp_start$time, prefix = "ann") %>%
na.omit()
PP_interpolate <- bind_cols(
PP_newdata,
predict(PP_gam,
newdata = PP_newdata,
# in addition to the predictions (fit) also return the standard error
# (se.fit) for each prediction. This makes predict return a named list,
# that we can simply bind to our data frame.
se.fit = TRUE)
)
ggplot(PP_interpolate, aes(x=time)) +
geom_ribbon(aes(ymin = fit - 1.96*se.fit,
ymax = fit + 1.96*se.fit,
fill = "Predicted (95% CI)")) +
geom_line(aes(y = fit)) +
geom_point(aes(y=PP, color = "Observed"), data = PP_data) +
scale_fill_manual(values = "skyblue")
```


```{r}
insp_rel_index_smooth <- gratia::smooth_estimates(PP_gam,
smooth = "s(ann_rel_index)",
n=100)
min_PP <- min(insp_rel_index_smooth$est)
max_PP <- max(insp_rel_index_smooth$est)
intercept_PP <- coef(PP_gam)[1]
PPV_est <- (max_PP - min_PP) / intercept_PP
sprintf("PPV is %.1f%%", PPV_est*100)
```

```{r}
set.seed(1)
insp_smooth_samples <- gratia::smooth_samples(PP_gam, term = "s(ann_rel_index)", n = 5000)
ggplot(insp_smooth_samples %>% filter(draw <= 50), aes(.x1, value, group = draw)) +
geom_line(alpha = 0.1) +
labs(x="ann_rel_index")
```

```{r}
# A function that returns PPV given a smooth and an intercept
calc_PPV <- function(smooth, intercept) {
  min_PP <- min(smooth)
  max_PP <- max(smooth)
  (max_PP - min_PP) / unname(intercept)
}
PPV_samples <- insp_smooth_samples$value %>%
  split(insp_smooth_samples$draw) %>%
  sapply(calc_PPV, intercept = coef(PP_gam)[1])
  PPV_95 <- quantile(PPV_samples, probs = c(0.025, 0.975))
ggplot(data.frame(PPV = PPV_samples), aes(x=PPV)) +
geom_histogram(bins=30) +
geom_vline(aes(xintercept = PPV_est, color = "Estimate"),
data = data.frame()) +
geom_vline(aes(xintercept = PPV_95, color = "95% confidence interval"),
data = data.frame()) +
scale_x_continuous(labels = scales::label_percent())
```



##### Moving gam





























##### Frederik

```{r}
# crude plot of Pulse Pressure

plot(beats$time, beats$PP, type='l')
#mov_avg <- rep(1/9, 9)
#PP_mov_avg <- filter(beats$PP, mov_avg)
#plot(beats$time, PP_mov_avg, type='l')
```


```{r}
# simple average func test (virker ikke bare som sig selv - vi skal have filtreret dataen)

test_time <- beats$time[6:51]
test_PP <- vector(length = 46)
for (i in c(6:51)){
  test_PP[i-5] <- sum(rep(1/11, 11) * beats$PP[(i-5):(i+5)])
}

plot(test_time, test_PP, type='l')
```


```{r}
# cheating (fjern alle værdier <15, da det virker til at være den slags støj vi finder mest her)
test_time <- beats$time
test_PP <- beats$PP

while (test_PP[1] < 15) {
  test_time <- test_time[2:length(test_time)]
  test_PP <- test_PP[2:length(test_PP)]
}

while (min(test_PP, na.rm = TRUE) < 15) {
  idx <- which.min(test_PP)
  test_time <- c(test_time[1:(idx-1)], test_time[(idx+1):length(test_time)])
  test_PP <- c(test_PP[1:(idx-1)], test_PP[(idx+1):length(test_PP)])
}

plot(test_time, test_PP, type='l')
points(test_time, test_PP, pch = 16, col='black')
abline(v = insp_start, col='red')

#GAM plot uden inspiration
waveformtools::PP_gam_analysis(beats, return_GAM = TRUE)|>  gratia::draw()
```

```{r}
# FRED COMM: Det virker til at der er lidt delay på PP / ins_start kommer for tidligt.
# Vi ville ellers "gerne se" at ins_start kommer samtidig med stigning i PP, men den kommer mest før
```





