---
title: "filter_load"
author: "Georg"
date: "5/11/2022"
output: html_document
---

```{r, message=FALSE}
library(devtools)
install_github('legendenomgeorg/VitalDBR/VitalDBR')
#library(VitalDBR, lib.loc="/Users/geo/repo/VitalDBR/VitalDBR")
library(VitalDBR)
library("tidyverse")
library(readr)
library(mgcv)
library(profvis)
library(data.table)
library(RcppRoll)
```
Det er åbenbart meget udfordrende at lave en funktion der kan tage en liste af argumenter, og så passe dem ind i filter funktionen, så det blir bare lige sådan her fremadrettet. Det hører nok også under basic r
```{r}
cases <- VitalDBR::load_VDB("https://api.vitaldb.net/cases") %>%
      dplyr::filter(approach=="Open",
                department=="General surgery",
                ane_type=="General") %>%
      dplyr::select(caseid, death_inhosp, icu_days, age, sex, asa, emop, bmi, opstart, opend)
cases
```

Har fjernet den dårlige version
# better version


Nå 3 min efter gik jeg havde sagt tak for i aften gik det op for mig at jeg kunne have gjort det meget mere simpelt. 
- Find alle caseid's der lever op til de der conditions ligesom ovenfor
- importer tracks med VitalDBR::load_VDB("https://api.vitaldb.net/cases")
- Find alle caseid's der har både Primus/AWP og SNUADC/ART. Og join de to tables. Så har man alle de case id'er vi skal finde
```{r}
tracks <- VitalDBR::load_VDB("https://api.vitaldb.net/trks") %>%
    dplyr::filter(tname == "Primus/AWP" | tname == "SNUADC/ART") %>%
    count(caseid) %>%
    dplyr::filter(n == 2)


```

```{r}
merged <- merge(x=tracks,y=cases,by="caseid") %>% dplyr::select(-one_of("n"))
#merged %>% dplyr::filter(death_inhosp==1)
#merged %>% dplyr::filter(icu_days>10)
```


```{r}
merged
```
Pas på med at fjerne NA, fordi så forsvinder nogle af de operationer hvor de døde!

```{r}
max(merged$icu_days)+1
table(merged$icu_days)
hist(merged$icu_days, breaks=82)
```

```{r}


#profvis({
calc_PPV <- function(smooth, intercept) {
min_PP <- min(smooth)
max_PP <- max(smooth)
(max_PP - min_PP) / unname(intercept)
}

ppv_prepare <- function(case, start, end, data_art, data_awp){
  # det tager usandsynligt lang tid, så vi skal have fixet den load funktion....
  # men ellers er det bare at implemetere PPV udregningen her
  op <- end - start
  interval <- 120
  iterations <- floor(op/interval)
  data <- c(matrix(NA, nrow=iterations))
  skip_to_next <- FALSE
  for (i in 0:iterations){
    sub_awp_trycatch <- tryCatch({
      sub_awp <- VitalDBR::subset_data(data = data_awp, seconds = interval, start_sec = start+(interval*i))
    },
    error = function(e){
      skip_to_next <<- TRUE
    })
    if(skip_to_next) { 
      data[i] <- NA
      next
      } 
    insp_start <- VitalDBR::get_inspiration_start(sub_awp)
    
    sub_art_trycatch <- tryCatch({
    sub_art <- VitalDBR::subset_data(data = data_art, seconds = interval, start_sec = start+(interval*i), filter=TRUE, cut_freq = 25)
    },
    error = function(e){
        skip_to_next <<- TRUE
    })
    if(skip_to_next) { 
      data[i] <- NA
      next
    }
    beats <- waveformtools::find_abp_beats(sub_art, abp_col=3, time_col=1)
    cat("nrow beats", nrow(beats))
    beats_indexed <- waveformtools::add_time_since_event(beats, time_event = insp_start$time)
    rm(beats)
    PP_data <- beats_indexed[,c("PP","time","ann_rel_index")]
    gam_try_catch <- tryCatch(
    {
      PP_gam <- gam(
      PP ~ 
      s(ann_rel_index,k = 10, bs = "cc" ) + s(time, k = 10, bs = "cr"), # splines
      knots = list(ann_rel_index = c(0,1)), method = "REML", data = PP_data )
      splines <- predict(PP_gam, type = "terms")
      
      data[i] <- calc_PPV(splines[,1], intercept = coef(PP_gam)[1])*100
      
      cat("Iteration",i, "out of ", iterations,". For case:",case)
      
      rm(PP_data)
      
    },
    error = function(e){
      skip_to_next <<- TRUE
    }
    )
    if(skip_to_next) { 
      data[i] <- NA
      next 
      } 
  }
  return(data)
}

process_cases <- function(data){
  ppv_under5 <- data.frame(matrix(NA, nrow = nrow(data)))
  ppv_over8 <- data.frame(matrix(NA, nrow = nrow(data)))
  counter <- 0 
  for (caseid in data$caseid){
    counter <- counter + 1 
    closeAllConnections()
    cat("Importing ART for case:",caseid)
    art <- VitalDBR::load_case('SNUADC/ART', caseid)
    cat("Importing AWP for case:",caseid)
    awp <- VitalDBR::load_case('Primus/AWP', caseid)
    start <- data$opstart[data$caseid==caseid] # This line and below could be optimized
    end <- data$opend[data$caseid==caseid] # - II -
    ppv_results <- na.omit(ppv_prepare(caseid, start, end, art,awp))
    rm(art)
    rm(awp)
    len_ppv <- length(ppv_results)
    ppv_under5[counter] <- sum(ppv_results<=5)/len_ppv
    ppv_over8[counter] <- sum(ppv_results>=8)/len_ppv
  }
  colnames(ppv_under5) <- c('ppv_under5')
  colnames(ppv_over8) <- c('ppv_over8')
  data <- cbind(data, ppv_under5)
  data <- cbind(data, ppv_over8)
  return(data)
}
startTime <- Sys.time()
ppv_data <- process_cases(merged[1,])
endTime <- Sys.time()
print(endTime - startTime)
View(ppv_data)
#})
```

```{r}
# data.frame: Time difference of 41.54168 secs 
# as.tibble: Time difference of 41.2858 secs
View(ppv_data)
```


```{r}
#path <- getwd()
#filename = paste(path, 'df_overnight.csv',sep = '')
#write.csv(ppv_data, filename)
```

```{r}
art <- VitalDBR::load_case('SNUADC/ART', 1)
awp <- VitalDBR::load_case('Primus/AWP', 1)
```

```{r}
if (nrow(art)/2 < length(art[,1]<=0) ){



```

```{r}
plot(art)
```

